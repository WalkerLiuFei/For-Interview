# 精选11道Java技术面试题并有答案（包含部分阿里和华为的面试题）

来源 ： https://zhuanlan.zhihu.com/p/34950698



\1. JVM的类加载机制是什么？有哪些实现方式？



类加载机制：

类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法去内，然后在堆区创建一个java.lang.Class对象，用来封装在方法区内的数据结构。类的加载最终是在堆区内的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。



类加载有三种方式：



1）命令行启动应用时候由JVM初始化加载



2）通过Class.forName（）方法动态加载



3）通过ClassLoader.loadClass（）方法动态加载



\2. JVM的常见垃圾回收算法？



1）标记-清楚算法：前后线标记处所有需要回收的对象，在标记完成后统一回收有被标记的对象。



2）复制算法：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当一块内存用完了，将其存在另外一块上面，然后再把已使用过的内存空间一次清理掉。



3）标记-整理算法：标记过程与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所一端移动，然后直接清理掉端边界以外的内存。



4）分代收集算法：一般是把Java堆分为新生代和老年代，根据各个年代的特点采用最适当的收集算法。新生代都发现有大批对象死去，选用复制算法。老年代中因为对象存活率高，必须使用“标记-清理”或“标记-整理”算法来进行回收。



\3. JVM调优的常见命令行工具有哪些？JVM常见的调优参数有哪些？



（1）JVM调优的常见命令工具包括：



1）jps命令用于查询正在运行的JVM进程，



2）jstat可以实时显示本地或远程JVM进程中类装载、内存、垃圾收集、JIT编译等数据



3）jinfo用于查询当前运行这的JVM属性和参数的值。



4）jmap用于显示当前Java堆和永久代的详细信息



5）jhat用于分析使用jmap生成的dump文件，是JDK自带的工具



6）jstack用于生成当前JVM的所有线程快照，线程快照是虚拟机每一条线程正在执行的方法,目的是定位线程出现长时间停顿的原因。



（2）JVM常见的调优参数包括：



-Xmx

指定java程序的最大堆内存, 使用java -Xmx5000M -version判断当前系统能分配的最大堆内存



-Xms

指定最小堆内存, 通常设置成跟最大堆内存一样，减少GC



-Xmn

　　设置年轻代大小。整个堆大小=年轻代大小 + 年老代大小。所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。



-Xss

　　指定线程的最大栈空间, 此参数决定了java函数调用的深度, 值越大调用深度越深, 若值太小则容易出栈溢出错误(StackOverflowError)



-XX:PermSize

　　指定方法区(永久区)的初始值,默认是物理内存的1/64， 在Java8永久区移除, 代之的是元数据区， 由-XX:MetaspaceSize指定



-XX:MaxPermSize

　　指定方法区的最大值, 默认是物理内存的1/4， 在java8中由-XX:MaxMetaspaceSize指定元数据区的大小



-XX:NewRatio=n

　　年老代与年轻代的比值，-XX:NewRatio=2, 表示年老代与年轻代的比值为2:1



-XX:SurvivorRatio=n

　　Eden区与Survivor区的大小比值，-XX:SurvivorRatio=8表示Eden区与Survivor区的大小比值是8:1:1，因为Survivor区有两个(from, to)



\4. ConcurrentHashMap加锁机制是什么，详细说一下？



HashTable容器在竞争激烈的并发环境下表现出效率低下的原因，是因为所有访问HashTable的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。



\5. G1收集器简介？以及它的内存划分怎么样的？



（1）简介：



Garbage-First（G1，垃圾优先）收集器是服务类型的收集器，目标是多处理器机器、大内存机器。它高度符合垃圾收集暂停时间的目标，同时实现高吞吐量。Oracle JDK 7 update 4 以及更新发布版完全支持G1垃圾收集器



（2）G1的内存划分方式：



它是将堆内存被划分为多个大小相等的 heap 区,每个heap区都是逻辑上连续的一段内存(virtual memory). 其中一部分区域被当成老一代收集器相同的角色(eden, survivor, old), 但每个角色的区域个数都不是固定的。这在内存使用上提供了更多的灵活性



\##

\6. 在重写equals方法时，需要遵循哪些约定，具体介绍一下？



重写equals方法时需要遵循通用约定：自反性、对称性、传递性、一致性.、非空性



1）自反性



对于任何非null的引用值x,x.equals(x)必须返回true。---这一点基本上不会有啥问题



2）对称性



对于任何非null的引用值x和y，当且仅当x.equals(y)为true时，y.equals(x)也为true。



3）传递性



对于任何非null的引用值x、y、z。如果x.equals(y)==true,y.equals(z)==true,那么x.equals(z)==true。



4） 一致性



对于任何非null的引用值x和y，只要equals的比较操作在对象所用的信息没有被修改，那么多次调用x.eqals(y)就会一致性地返回true,或者一致性的返回false。



5）非空性



所有比较的对象都不能为空。



\7. Synchronized优化后的锁机制简单介绍一下，包括自旋锁、偏向锁、轻量级锁、重量级锁？



自旋锁：



线程自旋说白了就是让cup在做无用功，比如：可以执行几次for循环，可以执行几条空的汇编指令，目的是占着CPU不放，等待获取锁的机会。如果旋的时间过长会影响整体性能，时间过短又达不到延迟阻塞的目的。



偏向锁



偏向锁就是一旦线程第一次获得了监视对象，之后让监视对象“偏向”这个线程，之后的多次调用则可以避免CAS操作，

说白了就是置个变量，如果发现为true则无需再走各种加锁/解锁流程。



轻量级锁：



轻量级锁是由偏向所升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁；



重量级锁



重量锁在JVM中又叫对象监视器（Monitor），它很像C中的Mutex，除了具备Mutex(0|1)互斥的功能，它还负责实现了Semaphore(信号量)的功能，也就是说它至少包含一个竞争锁的队列，和一个信号阻塞队列（wait队列），前者负责做互斥，后一个用于做线程同步。



偏向锁、轻量级锁、重量级锁的对比：





\8. Redis和Memcache区别对比？如何选择这两个技术？



区别：



1） Redis和Memcache都是将数据存放在内存中，都是内存数据库。不过memcache还可用于缓存其他东西，例如图片、视频等等。



2）Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储。



3）虚拟内存--Redis当物理内存用完时，可以将一些很久没用到的value 交换到磁盘



4）过期策略--memcache在set时就指定，例如set key1 0 0 8,即永不过期。Redis可以通过例如expire 设定，例如expire name 10



5）分布式--设定memcache集群，利用magent做一主多从;redis可以做一主多从。都可以一主一从



6）存储数据安全--memcache挂掉后，数据没了；redis可以定期保存到磁盘（持久化）



7）灾难恢复--memcache挂掉后，数据不可恢复; redis数据丢失后可以通过aof恢复



8）Redis支持数据的备份，即master-slave模式的数据备份。



选型：



若是简单的存取key-value这样的数据用memcache好一些



若是要支持数据持久化，多数据类型(如集合、散列之类的)，用列表类型做队列之类的高级应用，就用redis



\9. Redis的持久化机制是什么？各自的优缺点？



redis提供两种持久化机制RDB和AOF机制。



1）RDB持久化方式：



是指用数据集快照的方式记录redis数据库的所有键值对。



优点：



　　1.只有一个文件dump.rdb，方便持久化。



　　2.容灾性好，一个文件可以保存到安全的磁盘。



　　3.性能最大化，fork子进程来完成写操作，让主进程继续处理命令，所以是IO最大化。



　　4.相对于数据集大时，比AOF的启动效率更高。



缺点：



　　1.数据安全性低。



2）AOF持久化方式：



是指所有的命令行记录以redis命令请求协议的格式保存为aof文件。



优点：



　　1.数据安全，aof持久化可以配置appendfsync属性，有always，每进行一次命令操作就记录到aof文件中一次。



　　2.通过append模式写文件，即使中途服务器宕机，可以通过redis-check-aof工具解决数据一致性问题。



　　3.AOF机制的rewrite模式。



缺点：



　　1.文件会比RDB形式的文件大。



　　2.数据集大的时候，比rdb启动效率低。



\10. Mysql的数据库表锁、行锁、页级锁？



表级，直接锁定整张表，在你锁定期间，其它进程无法对该表进行写操作。如果你是写锁，则其它进程则读也不允许

行级,，仅对指定的记录进行加锁，这样其它进程还是可以对同一个表中的其它记录进行操作。

页级，表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。



\11. 数据库的四大特征，数据库的隔离级别？



数据库的四大特征：



（1）原子性（Atomicity）



原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚。



（2）一致性（Consistency）



一个事务执行之前和执行之后都必须处于一致性状态。



（3）隔离性（Isolation）



隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。



4）持久性（Durability）



持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的。



数据库的隔离级别：



1）Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。



2）Repeatable read (可重复读)：可避免脏读、不可重复读的发生。



3）Read committed (读已提交)：可避免脏读的发生。



4）Read uncommitted (读未提交)：最低级别，任何情况都无法保证。