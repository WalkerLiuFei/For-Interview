# java多线程在单核CPU上，还是需要volatile synchronized吗？


  首先，JMM是不区分是否JVM到底是运行在单核处理器、单核超线程处理器、多核处理器，抑或是多核超线程处理器上的。就是说，Java内存模型是对CPU内存模型的抽象，这是一个High-Level的概念，与具体的CPU平台没啥关系。

在单核处理器中，同一进程的不同线程访问进程中的共享数据时，CPU先将共享变量加载到共享缓存中，不同线程通过访问同一个进程的虚拟地址，虚拟地址经过MMU映射成物理地址，最终CPU通过物理地址去访问同一块缓存区域。因此在单核CPU中，如果该CPU存在着共享缓存，那么volatile的内存可见特性就显得无关紧要——因为不同线程无需通过主内存进行通信。但是对于多核CPU，由于需要解决缓存一致性问题（多核CPU中每个CPU缓存是相互独立的），所以需要通过主内存来通信解决缓存的数据同步问题，这时候volatile的可见性就显得尤为重要了。那单核处理器中volatile的意义是什么呢？我们知道为了提高程序指令的执行效率，CPU或编译器会对默认的程序指令进行重排序，对于Java程序而言，volatile通过插入读写屏障来禁止volatile变量之间的重排序。此外，JMM增强了volatile的语义——严格限制编译器和处理器对volatile变量与普通变量的重排序，确保volatile的写-读和监视器的释放-获取一样，具有相同的内存语义。



首先，JMM是不区分是否JVM到底是运行在单核处理器、单核超线程处理器、多核处理器，抑或是多核超线程处理器上的。就是说，Java内存模型是对CPU内存模型的抽象，这是一个High-Level的概念，与具体的CPU平台没啥关系。