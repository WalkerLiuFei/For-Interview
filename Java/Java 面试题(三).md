1. ThreadLocal用过么，原理是什么，用的时候要注意什么

   1. ThreadLocal 为每个线程提供一个线程本地变量，可以保证访问的数据属于当前线程。
   2. key 是一个 原子Integer 生成的 Hash Code 
   3. 具体实现类是ThreadLocalMap
2. **什么是自旋锁，偏向锁，轻量级锁，什么叫可重入锁，什么叫公平锁和非公平锁**
   1. 自旋锁 : 线程反复检查锁变量是否可用。由于线程在这一过程中保持执行，因此是一种[忙等待](https://zh.wikipedia.org/wiki/%E5%BF%99%E7%AD%89%E5%BE%85)。一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁。
   2. 避免进程上下文切换，但是浪费CPU资源
      2. 自适应自旋锁 ： 自适应自旋可以根据以往自旋等待时间的经验，计算出一个较为合理的本次自旋等待时间。
   3. 偏向锁，属于乐观锁，即认为同步期间不会有其他线程竞争锁。当线程请求到锁对象后，将锁对象的状态标志位改为01，即偏向模式。然后使用CAS操作将线程的ID记录在锁对象的Mark Word中。以后该线程可以直接进入同步块，连CAS操作都不需要。但是，一旦有第二条线程需要竞争锁，那么偏向模式立即结束，进入轻量级锁的状态。
   4. **悲观锁** ： 总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（**共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程**）。传统的关系型数据库。`Java`中`synchronized`和`ReentrantLock`等独占锁就是悲观锁思想的实现。
   5. **乐观锁** : 总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，像数据库提供的类似于`write_condition`机制，其实都是提供的乐观锁。在`Java`中`java.util.concurrent.atomic`包下面的**原子变量类就是使用了乐观锁的一种实现方式CAS实现的**。
   6. **可重入锁**  ：  广义上的可重入锁指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁(**前提是锁的对象是同一个**)， `ReentrantLock`和`synchronized`都是可重入锁
   7. **不可重入锁 ：** 不可重入锁，与可重入锁相反，不可递归调用，如果递归调用就会发生死锁。
   8. **非公平锁**  ： 线程在请求锁的时候，如果可用即获得锁，不进入队列等待。**Synchronized** 代码块的实现是非公平锁
   9. **公平锁** ： 线程在请求锁的时候首先进入队列等待，例如ReentrantLock ，可以实现公平锁，当然需要**AQS** 来进行协助
7. concurrenthashmap具体实现及其原理，jdk8下的改版
   1. 引入了 lamada表达式
4. 用过哪些原子类，他们的参数以及原理是什么
   1. 原理就是CAS，Compare And Set
9. 如果让你实现一个并发安全的链表，你会怎么做
10. 简述AQS的实现原理
   1. 
11. countdowlatch和cyclicbarrier的用法，以及相互之间的差别?
    1. CountDownLatch : **一个线程**(或者多个)， 等待另外**N个线程**完成**某个事情**之后才能执行。   
    2. CyclicBarrier        : **N个线程**相互等待，任何一个线程完成之前，所有的线程都必须等待。
12. concurrent包中使用过哪些类？分别说说使用在什么场景？为什么要使用？
13. LockSupport工具
    1. LockSupport结合`UNSAFE` 里面native 方法为AQS 提供支持，主要是两个方法，park和unpark，park方法用来阻塞线程，UNpark 方法用来唤醒线程
14. Condition接口及其实现原理
15. Fork/Join框架的理解
16. jdk8的parallelStream的理解
17. 分段锁的原理,锁力度减小的思考