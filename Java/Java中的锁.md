# Java中 的各种锁

## 自旋锁与互斥锁



1. **自旋锁**  : 线程反复检查锁变量是否可用。由于线程在这一过程中保持执行，因此是一种[忙等待](https://zh.wikipedia.org/wiki/%E5%BF%99%E7%AD%89%E5%BE%85)。一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁。
   1. **优点是避免线程出现上下文切换**， **缺点是，一些循环等待浪费CPU资源**
   2. 自适应自旋锁 ： 自适应自旋可以根据以往自旋等待时间的经验，计算出一个较为合理的本次自旋等待时间。
2. **互斥锁** ： **线程在获取锁时，如果锁不可用那么线程就进入睡眠，等待锁可用时被唤起。线程在这期间会出现 用户态和系统态的上线文切换** 

## 偏向锁 / 轻量级锁 / 重量级锁

1. **偏向锁** : 属于乐观锁，即认为同步期间不会有其他线程竞争锁。当线程请求到锁对象后，将锁对象的状态标志位改为01，即偏向模式。然后使用CAS操作将线程的ID记录在锁对象的Mark Word中。**以后该线程可以直接进入同步块，连CAS操作都不需要。但是，一旦有第二条线程需要竞争锁，那么偏向模式立即结束，进入轻量级锁的状态。**
2. **轻量级锁** ： 是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，**其他线程会通过自旋的形式尝试获取锁**，不会阻塞，提高性能。
3. **重量级锁 ** ： 是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。



## 悲观锁与乐观锁

1. **悲观锁** ： 总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（**共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程**）。传统的关系型数据库。`Java`中`synchronized`和`ReentrantLock`等独占锁就是悲观锁思想的实现。
2. **乐观锁** : 总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，像数据库提供的类似于`write_condition`机制，其实都是提供的乐观锁。在`Java`中`java.util.concurrent.atomic`包下面的**原子变量类就是使用了乐观锁的一种实现方式CAS实现的**。

## 重入锁和不可重入锁

1. **可重入锁**  ：  广义上的可重入锁指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁(**前提是锁的对象是同一个**)， `ReentrantLock`和`synchronized`都是可重入锁
2. **不可重入锁 ：** 不可重入锁，与可重入锁相反，不可递归调用，如果递归调用就会发生死锁。

## 公平锁和不公平锁

1. **非公平锁**  ： 线程在请求锁的时候，如果可用即获得锁，不进入队列等待。**Synchronized** 代码块的实现是非公平锁，不公平所可能会出现一些线程持续无法获得锁，从而出现线程饿死的情况 
2. **公平锁** ： 线程在请求锁的时候首先进入队列等待，例如ReentrantLock ，可以实现公平锁，当然需要**AQS** 来进行协助