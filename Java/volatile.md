# volatile作用

1. 保证内存变量实时可见性
2. 防止指令重拍

## 内存可见性

### 线程的工作内存

Java内存模型规定，对于多个线程共享的变量，存储在主内存当中，每个线程都有自己独立的工作内存（比如CPU的寄存器），线程只能访问自己的工作内存，不可以访问其它线程的工作内存。工作内存中保存了主内存共享变量的**副本**，线程要操作这些共享变量，只能通过操作工作内存中的副本来实现，操作完毕之后再同步回到主内存当中。

### 8种原子操作

1. lock ： 锁定主内存的变量
2. unlock : 解锁
3. read : 将主内存的变量读取到工作内存中
4. load : 将read读取的值保存到工作内存中的变量副本中。
5.  use:将值传递给线程的代码执行引擎
6. assign:将执行引擎处理返回的值重新赋值给变量副本
7. store:将变量副本的值存储到主内存中。
8. write:将store存储的值写入到主内存的共享变量当中。



## 指令重拍

指令重排序是JVM为了优化指令，提高程序运行效率，在不影响单线程程序执行结果的前提下，尽可能地提高并行度。编译器、处理器也遵循这样一个目标。注意是单线程。多线程的情况下指令重排序就会给程序员带来问题。

