# Zookeeper  

[参考](https://www.jianshu.com/p/b5f99fdb1957)

开放源码的**分布式应用程序协调服务**，是Google的Chubby一个开源的实现，它是**集群的管理者，监视着集群中各个节点的状态根据节点提交的反馈进行下一步合理操作**。最终，将简单易用的接口和性能高效、功能稳定的系统提供给用户

Zookeeper提供了

1. ***文件系统（持久化节点  和  临时节点的使用可以方便进行服务注册和服务发现等集群管理  以及顺序编号可以方便实现分布式锁（保持时序的）和分布式队列（先进先出）以及命名服务）***
2. ***通知机制（监听机制可以实现 数据的发布与订阅 负载均衡 以及配置管理）*** 

## Zookeeper一致性协议ZAB的原理

Zookeeper 的一致性原理使用的其实就是 paxos的变形，

## Zookeeper的结构

### 文件系统

每个子目录项如 NameService 都被称作为znode，和文件系统一样，我们能够自由的增加、删除znode，在一个znode下增加、删除子znode，**唯一的不同在于znode是可以存储数据的。**

有四种类型的znode：（临时节点可以用来服务发现 服务注册   顺序编号可以用来实现保持时序的分布式锁 命名服务（分布式自增id）分布式队列先进先出 ）

1. PERSISTENT-持久化目录节点：客户端与zookeeper断开连接后，该节点依旧存在

2. PERSISTENT_SEQUENTIAL-持久化顺序编号目录节点：客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号

3. EPHEMERAL-临时目录节点：客户端与zookeeper断开连接后，该节点被删除（node_0000000001）

4. EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点：客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号

### 通知机制

客户端注册监听它关心的目录节点，当目录节点发生变化（数据改变、被删除、子目录节点增加删除 实现对应接口时，调用对应的函数实现--回调）时，zookeeper会通知客户端。（zklient订阅 指定路径的监听接口）



## Zookeeper的应用场景

### 命名服务

在zookeeper的文件系统里创建一个目录，即有唯一的path。在我们使用tborg无法确定上游程序的部署机器时即可与下游程序约定好path，通过path即能互相探索发现。（临时节点顺序编号）

### 配置管理 

程序总是需要配置的，如果程序分散部署在多台机器上，要逐个改变配置就变得困难。现在把这些配置全部放到zookeeper上去，保存在 Zookeeper 的某个目录节点中，然后所有相关应用程序对这个目录节点进行监听，一旦配置信息发生变化，每个应用程序就会收到 Zookeeper 的通知，然后从 Zookeeper 获取新的配置信息应用到系统中就好。

### 集群管理

所谓集群管理无在乎两点：是否有机器退出和加入（服务发现）、选举master。

对于第一点，所有机器约定在父目录GroupMembers下创建临时目录节点，然后监听父目录节点的子节点变化消息。一旦有机器挂掉，该机器与 zookeeper的连接断开，其所创建的临时目录节点被删除，所有其他机器都收到通知：某个兄弟目录被删除，于是，所有人都知道：它上船了。（临时节点和监听机制）

新机器加入也是类似，所有机器收到通知：新兄弟目录加入，highcount又有了，对于第二点，我们稍微改变一下，所有机器创建临时顺序编号目录节点，每次选取编号最小的机器作为master就好。

### 分布式锁

有了zookeeper的一致性文件系统，锁的问题变得容易。锁服务可以分为两类，一个是保持独占（监听机制），另一个是控制时序（顺序编号和监听机制）。

对于第一类，我们将zookeeper上的一个znode看作是一把锁，通过createznode的方式来实现。所有客户端都去创建 /distribute_lock 节点，最终成功创建的那个客户端也即拥有了这把锁。用完删除掉自己创建的distribute_lock 节点就释放出锁。

对于第二类， /distribute_lock 已经预先存在，所有客户端在它下面创建临时顺序编号目录节点，和选master一样，编号最小的获得锁，用完删除，依次方便。

## Zookeeper中常见的坑

