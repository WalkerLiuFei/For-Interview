## MYSQL索引

1. **描述B+Tree 数据结构**

2. InnoDB 的自适应Hash索引

3. **B+ Tree 数据结构是怎样维护索引的？**

   1. B+ Tree 相对于B-Tree 来讲，B+Tree 的叶子节点都包含有 指向下一个叶子节点的指针。从而方便叶子节点的范围遍历
   2. 

4. **B Tree索引存在的限制？**

5. **索引带来的三条优点**、

   1. 索引大大降低了服务器需要扫描的数据行的数量
   2. 索引可以帮助服务器避免排序和创建临时表
   3. **索引可以将随机IO变为顺序IO(这个参考MYSQL的数据存储格式)**

6. **对于大中小各个规模的数据，索引是不是都是最优的选择？如果不是，怎么根据**

7. **Hash索引的优势与劣势？**

8. **BTree索引怎样通过模拟Hash索引来进行**

   1. 假设有一个存储URL 的列，如果直接直接在这个列上面建立索引，肯定造成索引文件大，并且效率低，解决办法是建立一个 URL_CRC l列，通过在这列上建立索引达到提升效率的目的。
   2. 注意不要**直接使用**SHA1()或者MD5作为Hash函数，因为这些函数的结果很大，增加Mysql数据存储的负担。

9. **Innodb是怎样使用Hash索引的？它带来的性能优化的点在哪里？**

   1. InnoDB有一个功能是，当检测到某个索引值被使用的非常频繁是，会在上面自动建立一个Hash索引的， 通过在这样的方式可以使得InnoDB也具有Hash索引的优势。

10. **怎样计算索引列的选择性？写出对应的SQL语句**，前缀索引的缺陷

   1. 假设我们现在有个`city` 字段，但是由于这个`city` 字段的数据类型太长，如果在上面直接建立索引的话肯定会造成索引文件很大。
   2. 通过`select count (DISTINCT LEFT(city,3) / COUNT(*)) FROM CIYY_DEMO_TABLE` 来计算`city`字段只通过`city` 前3个字符建立前缀索引的话，选择性是怎样的。
   3. 前缀索引无法进行 `order by` 和`GROUP BY` 操作。

   

11. **MYSQL中各个索引的命名都有那些**

    1. 聚簇索引
    2. 多列索引
    3. 前缀索引
    4. Hash索引
    5. B Tree索引

12. 索引合并策略要解决的问题 

    1. 当服务器出现多个索引列的 AND 操作条件时。
    2. 当服务器需要对多个索引做联合操作时，通常需要消耗大量CPU和内存资源在算法的缓存，排序和合并操作上。特别是当其中有些索引的选择性不高时
    3. 更重要的是，优化器不会将这些计算到查询成本中，优化器只关心随机IO读写。这会使得查询成本被低估，导致走索引还不如直接进行全表扫描。

13. **什么是覆盖索引？覆盖索引带来的优势？**

14. **对于联合索引，将选择性最高的列放入最前列，一般会是最佳的选择**

15. **什么是聚簇索引？有什么用到的业务场景?有什么缺点**

    1. 聚簇索引并不适合一种单独的索引类型，而是一种数据存储方式，聚簇的意思是数据行和它相邻的键值紧紧的存储在一起，
    2. 因为无法将数据行放在两个地方，所以一个表只有一个聚簇索引。不过覆盖索引可以模拟 一个表有多个聚簇索引的情况
    3. 在B+Tree 中，叶子节点包含了行的全部数据，而节点页只包含了索引列数据。
    4. 一般的，在InnoDB中，通过主键作为key 构建聚簇索引，如果没有指定主键，那么通过一个非空索引来进行，如果连索引都没，会创建一个隐式的主键。

16. 聚簇索引的优点

    1. 可以将相关数据绑定在一起
    2. 数据访问更快
    3. 使用覆盖索引扫描的查询可以直接使用叶节点的主键值。

17. 聚簇索引（主键索引）的缺陷

    1. 可能会增加内存的压力，因为毕竟读取
    2. 插入速度依赖插入顺序。如果主键是自增的 id还好，如果不是的
    3. 更新聚簇索引的代价很高，因为会造成InnoDB存储的大量数据行的移动
    4. **二级索引需要两次索引查找** 
    5. 聚簇索引可能会导致全表扫描变的很慢
    6. 二级索引(非聚簇索引)可能会变的很大
    7. **聚簇索引可能会导致页分裂问题（什么是页分裂？）**

18. 对于主键 

    1. 主键应该与业务无关，应该是一个自增的 INT 型的一个单独的column，这样可以保证数据的插入是通过主键顺序插入的。

    2. 避免使用UUID 之类的数据列建立主键索引，这大概率**会造成数据插入时导致 行移动**

       

19. **InnoDB的二级索引和聚簇索引的区别？怎样辨别一个索引是二级索引？还是聚簇索引? 那种索引在特定的业务场景中更有优势？**

    1. 二级索引存储的叶子节点存储的不是 **数据行所在的物理指针**，而是主键的键值，并以此指向行。二次索引这样可以减少对数据更新时出现的行的数据出现物理移动。

     

20. **顺序主键的弊端是什么，在什么时候会有性能问题 ,什么是AUTO_INCREMENT LOCK **

    1. 对于高并发工作负载,在Innodb中按主键顺序插入可能会造成明显的争用.主键的上界会成为`"热点"` .因为所有的插入都发生在这里,所以并发插入可能导致间隙锁竞争.另一个热点可能是AUTO_INCREMENT锁机制.如果遇到这个问题,则可能考虑重新设计表或者应用,或者更改innodb_autoinc_lock_mode配置.如果你的服务器版本还不支持,可以升级到最新版

21. **是不是索引每次都能被使用**

    1. 不一定，想象一下，当使用索引查询大量数据时，

       + 使用 索引 ： 使用索引相当于进行两次IO，一次进行索引定位，另一次通过索引的二次查找定位到具体的列，而第二次IO基本上都是随机IO
       + 不适用索引 ： 如果进行全表扫描就不一样，进行只需要进行一次IO即可。

       

22. **覆盖索引**

    1. **如果一个索引包含(或者覆盖)所有需要查询的字段的值,我们就称为"覆盖索引"**
    2. 覆盖索引其实只是一个普通的索引，只是要查询的数据在索引上面，这样就不需要进行二次的磁盘读取。
    3. 一条查询语句在`explain` 的结果 列中的`extra` 列 是`USING INDEX` 则表明覆盖索引起效了。

23. **怎样才能让排序使用上索引？**

    1. 只有当索引的列顺序和`ORDER BY `子句的顺序完全一致，**并且所有列的排序方向（倒序/正序）一致时才会用到索引**

24. **MYSQL 的唯一 限制（unique）和主键（primary key）都是通过索引实现的。在这种列上面建立索引，犹如画蛇添足，影响写的性能**

25. **联合索引（A,B）和索引A  是不是退鱼索引？ （B,A）联合索引和索引A哪？**

    1. 第一个是，第二个不是

26. **对于使用锁的类型来说,InnoDB在访问主键索引和访问二级索引的区别在哪里？**

    1. 索引可以让查询锁定更少的行
    2. InnoDB在访问二级索引上使用共享(读)锁，在访问主键索引上使用排他(写)锁。

27. 如果表结构或索引有损坏，可以用那条语句快速修复？

    1. `ALTER TABLE example_table ENGINE=INNODB`

28. `Btree` 需要进行随机访问才能访问到叶子节点，行碎片，行间碎片，剩余空间碎片

    1. 根据设计`B-Tree`需要通过随机磁盘IO才能访问到叶子页，所以随机访问是不可避免的。

29. 可以定期使用那条语句来优化数据表？

30. **通过什么方式可以消除索引的碎片化？**

    1. `OPTIMIZE  TABLE`

31. 编写查询语句时，应尽可能选择合适的索引以避免单行查找，尽可能第使用数据原生顺序，从而避免额外的排序操作，并尽可能的使用索引覆盖查询

32. 

33. 

------------------------



