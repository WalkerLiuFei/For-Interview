# Mysql锁的问题

## MyISAM 的锁 

- MyISAM总是一次SQL语句需要的全部锁，这也是为什么MyISAM表不会出现死锁的原因。
- 在一个session中显式的为一个表加读锁后，通过别名读取这个锁，同样会被拒绝
- 在MyISAM中，Session在获取一个表的读锁后，就不能再查询/更新其他表
- **MyISAM中写锁的优先级总是高于读锁，这也是为什么MyISAM不适合大量更新和查询操作的原因**
- Mysql的并发插入机制 通过一个系统变量 concurrent_insert 进行

## InnoDB 锁

> InnoDB的特性就是支持事务和行级锁

- 事务及其ACID 属性
- 原子性(Atmoicty)：事务是一个原子操作单元，其对数据的修改要么全部完成，要么全部回滚
- 一致性（Consistent）：在事务开始和完成时 ，数据
- 隔离性（Isolation）
- 持久性（Durable） ：事务完成后，它对数据的修改是永久性的。
- 通过检查 InnoDB_row_lock状态变量可以分析系统上的行锁争用状况

InnoDB的两种锁：

- 共享锁：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁
- 排它锁：允许排它锁的事务更新数据，组织其他事务获得相同数据集的
- InnoDB行锁的三种情形，**简洁的说，InnoDB对数据的加锁都是通过索引对数据的加锁**
- Record lock ：对缩影加锁
- Gap lock：对索引项之间“间隙“ 加锁
- Next-key lock ： 前面两种的组合，对索引项和前面的间隙加锁
- **InnoDB的这种行锁机制意味着，如果不对数据加索引，那么InnoDB将对所有记录都加锁，效果和表锁没有区别**
- 在分析InnoDB的锁冲突时不要忘记检查是否使用了索引
- **通过设置合适的锁等待超时阈值，可以避免死锁带来问题**
- **避免死锁的措施**
- 在应用中，如果不同的程序会并发的访问不同的表，应尽量以相同顺序去访问表，这样可以大大降低发生死锁的几率
- 在程序以批量处理方式处理数据时，如果事先对数据排序，保证每个线程按固定的顺序来处理数据，可以大大降低出现死锁的可能
- 在事务中，直接申请足够级别的锁，即排它锁
- 尽量使用较低的隔离级别
- 精心设计索引，使得加锁更精确，减少锁冲突
- 选择合适的事务大小，小事务发生的锁冲突几率更小
- 在出现死锁时，利用show innoDB status命令来确定最后一个死锁出现的原因