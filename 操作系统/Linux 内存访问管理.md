## 虚拟内存

linux 系统内的应用都是访问的都是虚拟内存，虚拟内存是真实物理的内存的映射，各自不可互相见，虚拟内存和物理内存的映射通过`MMU`（memory management unit）管理这个映射。另外，`MMU` 管理内存并不是以字节为单位进行内存管理的，而是以页表的方式，每一个页表的大小为 `4k`

### 虚拟内存

虚拟地址空间内部又被分成**内核空间**和**用户空间。**32位和64位系统的内存寻址空间，如下图：

**![img](https://img2018.cnblogs.com/blog/1268024/201907/1268024-20190723172957431-1021700614.png)**

**虚拟内存的空间分布**

**![img](https://img2018.cnblogs.com/blog/1268024/201907/1268024-20190724170232462-1816515695.png)**

- 只读段： 代码和常量
- 数据段：全局变量
- **堆：动态分配内存，从低地址开始向上增长**
- 文件映射段： 动态库、共享内存
- 栈： 局部变量，函数调用的上下文，栈大小一般固定是8MB

### **内存分配**：

malloc()是C标准库提供的内存分配函数，对应到系统调用上，有两种实现方式，即`brk()`和`mmap()`。

`brk()` 分配小于128k的内存，会调用这个方法， 分配的内存在被应用释放以后会缓存起来，并不会归还给系统。这样的方式可以降低缺页风险，但是容易造成内存碎片

`mmap()` 分配`>128k` 的内存，应用释放后会归还给系统，没有内存碎片问题，但是容易造成访问缺页的情况。

所谓**缺页异常**是指当进程访问的虚拟地址在页表中查不到时，系统会产生一个**缺页异常**，进入内核空间分配物理内存、更新进程页表，最后再返回用户空间、恢复进程运行

### **内存回收**：

- 回收缓存，比如使用LRU算法，回收最近使用最少的内存页面
- 回收不常用的内存，把不常用的内存通过交换分区直接写到磁盘（swap）
- 杀死进程，内存紧张时系统会通过(OOM)直接干掉进程

　　

**关于OOM**，linux系统通过oom_score为每个进程的内存使用情况进行评分:

- 一个进程消耗的内存越大，oom_score就越大
- 一个进程运行占用的CPU越多，oom_score就越小 

```
$ ``free` `-m
       ``total    used    ``free`   `shared buff``/cache`  `available
Mem:     15713    3351    7945     594    4417    11487
Swap:     4095      0     4095
```

- total： 总内存大小；
- used： 已用内存大小，包含共享内存
- free： 未用内存的大小
- shared: 共享内存的大小
- buff/cache: 缓存和缓冲区的大小
- available: 新进程可用内存的大小，不仅包含未使用内存，还包含了可回收的缓存，所以一般比未使用内存更大。不过不是所有缓存都可以回收，因为有些缓存可能正在使用中。

　　

　　其中缓存是Buffer和Cache两部分的总和。Buffer是缓冲区，Cache是缓存，两者都是数据在内存中的临时存储。

- Buffers

- - 是内核缓存区用到的内存，对应的是/proc/meminfo中的Buffers值

  - 深层次上来说buffers是原始磁盘块的临时存储，也就是用来**缓存磁盘的数据**，通常不会特别的大(20MB左右)，这样，内核就可以把分散的写集中起来，统一优化磁盘吸入

    

- Cache

  - 是内核页缓存和 Slab 用到的内存，对应的是/proc/meminfo 中的Cached与SReclaimable之和。
  - 从磁盘读取文件的页缓存，也就是用来**缓存从文件读取的数据**，这样下次访问的时候就可以直接从内存中快速获取，而不需要再次访问缓慢的磁盘。
  - 关于SReclaimable是Slab的一部分，Slab包括可回收和不可回收部分