# Linux 对内存 页表的优化

[参考](https://www.cnblogs.com/richardzgt/articles/11233687.html)

### 虚拟内存（MMU）

Linux内核给每个进程都提供了一个独立的**虚拟空间**，并且这个地址空间是连续的。这样，进程就可以很方便地访问内存，更确切地说是访问虚拟内存。

虚拟地址空间内部又被分成**内核空间**和**用户空间。** 因为每个系统对系统其他应用的内存状态不可见，所以每个应用都有一个单独的虚拟内存

MMU并不以字节为单位来管理内存，而是规定一个内存映射的最小单位，也就页，通常是4kB，所以出现了**多级页表**和**大页**(HugePage)来解决这个问题

![img](https://img2018.cnblogs.com/blog/1268024/201907/1268024-20190724170232462-1816515695.png)

- 只读段： 代码和常量
- 数据段：全局变量
- 堆：动态分配内存，从低地址开始向上增长
- 文件映射段： 动态库、共享内存
- 栈： 局部变量，函数调用的上下文，栈大小一般固定是8MB

 

### **内存分配**

malloc()是C标准库提供的内存分配函数，对应到系统调用上，有两种实现方式，即brk()和mmap()。对小块内存 小于 128k的内存，使用`brk()` 函数，对于大于 `128k`的内存分配请求，使用`mmap()` 函数。

使用`brk()` 分配的内存，因为分配使用之后会缓存起来，而不交还给系统，所以频繁的`brk`调用容易造成内存碎片

使用`mmap()` 分配的内存，因为内存释放后会交还给系统，所以容易造成缺页异常，并且会增大系统管理内存的负担

### 内存的使用

　**内存回收**：

- 回收缓存，比如使用LRU算法，回收最近使用最少的内存页面
- 回收不常用的内存，把不常用的内存通过交换分区直接写到磁盘（swap）
- 杀死进程，内存紧张时系统会通过(OOM)直接干掉进程，每个应用都有一个oom_score的变量，一个应用占用的 内存越大，oom_score 分值越高，在OOM时越容易被杀死





　　**查看内存的使用情况：** 

```
 $ free -m
              total        used        free      shared  buff/cache   available
Mem:          15713        3351        7945         594        4417       11487
Swap:          4095           0        4095
```

　　物理内存Mem和交换分区Swap分成两个表。分别表示为：

- total： 总内存大小；
- used： 已用内存大小，包含共享内存
- free： 未用内存的大小
- shared: 共享内存的大小
- buff/cache: 缓存和缓冲区的大小
- available: 新进程可用内存的大小，不仅包含未使用内存，还包含了可回收的缓存，所以一般比未使用内存更大。不过不是所有缓存都可以回收，因为有些缓存可能正在使用中。

　　

　　其中缓存是Buffer和Cache两部分的总和。Buffer是缓冲区，Cache是缓存，两者都是数据在内存中的临时存储。

- Buffers

- - 是内核缓存区用到的内存，对应的是/proc/meminfo中的Buffers值

  - 深层次上来说buffers是原始磁盘块的临时存储，也就是用来**缓存磁盘的数据**，通常不会特别的大(20MB左右)，这样，内核就可以把分散的写集中起来，统一优化磁盘吸入

    

- Cache

  - 是内核页缓存和 Slab 用到的内存，对应的是/proc/meminfo 中的Cached与SReclaimable之和。
  - 从磁盘读取文件的页缓存，也就是用来**缓存从文件读取的数据**，这样下次访问的时候就可以直接从内存中快速获取，而不需要再次访问缓慢的磁盘。**
    **
  - 关于SReclaimable是Slab的一部分，Slab包括可回收和不可回收部分

　　简单来说，**Buffer是对磁盘数据的缓存，而Cache是文件数据的缓存，它们既会用在读请求中，也会用在写请求中**。　　

 

 　我们知道free是整个系统的内存使用情况，如果看单个进程，则使用top或者ps

```
# top
..........
Mem:  32864280k total,  4563552k used, 28300728k free,   377268k buffers
Swap: 20479996k total,        0k used, 20479996k free,  1906592k cached
 
   PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND                             
  3298 root      20   0  698m 572m 1272 S  2.5  1.8 903:53.47 redis-server 10.3.90.5:7001 [cluster]
  3294 root      20   0 1239m 1.1g 1260 S  1.2  3.5 435:42.90 redis-server 10.3.90.5:7000 [cluster]
     1 root      20   0 19368 1552 1232 S  0.0  0.0   0:31.10 /sbin/init   
```

- `VIRT`是**进程虚拟内存**的大小，只要是进程申请过的内存，即便是还没有真正分配物理内存，也会计算在内
- `RES`是**常驻内存**的大小，也就是进程实际使用的物理内存大小，但不包括SWAP和共享内存
- `SHR`是**共享内存**的大小，比如与其进程共同使用的共享内存、加载的动态链接库及程序的代码段等
- `%MEM`是进程使用**物理内存**占系统总内存的百分比

　需要注意的两点信息：

　　1 虚拟内存通常并不会全部分配物理内存。从上面的输出看到每个进程的虚拟内存都比常驻内存大一些

　　2 共享内存SHR并不一定是共享的，比如说程序的代码段、非共享的动态链接库，也都算在SHR里面。当然SHR也包括了进程间真正共享的内存，所以在计算的时候不能把所有进程的SHR直接相加。