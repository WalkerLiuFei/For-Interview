# HTTPS探究（非对称加密算法 RSA）

+ [参考 1 ](https://www.jianshu.com/p/67bcb140d804)
+ 

## X509 public key format

**X.509** 是密码学里[公钥证书](https://zh.wikipedia.org/wiki/%E5%85%AC%E9%92%A5%E8%AF%81%E4%B9%A6)的格式标准。 X.509 证书己应用在包括[TLS/SSL](https://zh.wikipedia.org/wiki/TLS/SSL)在内的众多 Intenet协议里.同时它也用在很多非在线应用场景里，比如电子签名服务。 

X.509证书里含有公钥、身份信息（比如网络主机名，组织的名称或个体名称等）和签名信息（可以是证书签发机构CA的签名，也可以是自签名）。

X.509颁发 在X.509里，组织机构通过发起证书签名请求（[CSR](https://zh.wikipedia.org/wiki/CSR)）来得到一份签名的证书。首先需要生成一对钥匙对，然后用其中的私钥对CSR进行签名，并安全地保存私钥。CSR进而包含有请求发起者的身份信息、用来对此请求进行验真的的公钥以及所请求证书专有名称。CSR里还可能带有CA要求的其它有关身份证明的信息。然后CA对这个专有名称发布一份证书，并绑定一个公钥. 组织机构可以把受信的根证书分发给所有的成员，这样就可以使用公司的PKI系统了。像Firefox, IE, Opera, Safari 以及Google Chrome都预装有早就确定的根证书列表，所以使用主流CA发布的证书SSL都直接可以正常使用。浏览器的开发者直接影响着它的用户对第三方的信任。FireFox就提供了一份csv/html格式的列表[[2\]](https://zh.wikipedia.org/wiki/X.509#cite_note-2) X.509也定义了CRL实现标准。另一种检查合法性的方式是OCSP。

### 公匙和私匙

HTTPS 中，**【公匙加密，私匙解密。】 【私匙签名，公匙验证】**这是一个相对而言的说法。在理论上，RSA算法的公匙和私匙都是相对而言的，那个放出去，那个就是公匙。



### HTTPS是否是完全用的非对称加密

**HTTPS 的通信过程中只在握手阶段使用了非对称加密，后面的通信过程均使用的对称加密。尽管非对称加密相比对称加密更加安全，但也存在两个明显缺点**

1. CPU 计算资源消耗非常大。一次完全 TLS 握手，密钥交换时的非对称解密计算量占整个握手过程的 90% 以上。而对称加密的计算量只相当于非对称加密的 0.1%，如果应用层数据也使用非对称加解密，性能开销太大，无法承受。
2. 非对称加密算法对加密内容的长度有限制，不能超过公钥长度。比如现在常用的公钥长度是 2048 位，意味着待加密内容不能超过 256 个字节。

所以公钥加密目前只能用来作密钥交换或者内容签名，不适合用来做应用层传输内容的加解密。

非对称密钥交换算法是整个 HTTPS 得以安全的基石，充分理解非对称密钥交换算法是理解 HTTPS 协议和功能的关键。对于数字签名而言，服务端对数据进行HASH摘要，然后用RSA的私匙对这个摘要进行签名。一般来说是Hash-256算法，这个还是能很好的防止Hash碰撞的。服务端对数据签名，然后发给客户端。客户端利用公匙验证。这个签名。计算出Hash值，最后验证从服务器传输过来的数据是否被篡改过。

在握手阶段，client和server 端使用非对称加密完成握手，完成握手以后，利用生成的session secret key 作为对称加密的密匙对传输内容进行对称加密，也就是说客户端和服务端之间对称加密使用的密匙是动态的，这样就解决了对称机密密匙保存的问题

### HTTPS 握手过程

1. 客户端发出握手请求，包含以下信息
   1. 支持的协议版本号
   2. 支持的加密算法
   3. 支持的压缩算法
   4. 一个客户端生成的随机数
2. 服务端响应：
   1. 确认	协议，加密算法，压缩算法
   2. 服务证书
   3. 一个服务端随机生成的随机数
3. 客户端回应
   1. 验证证书合法性
   2. 生成一个48字节的加密key，又称为preMasterKey
   3. 客户端握手结束通知
4. 服务器回应，服务器通过上面的三个随机数(random_1,random_2,PreMaster Secret)，计算出本次会话的『会话密钥(session secret)』，然后向客户端发送下面信息
   - 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。
   - 服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。







----------------

# HTTPS中的数学

### 数理基础

两个正整数，除了1意外没有相同的公因子，那么就称之为互质关系例如15和32

**欧拉函数：**求一个大于1 的正整数互质关系的数的个数

基于算数基本定理 即 **每个大于1的[自然数](https://zh.wikipedia.org/wiki/%E8%87%AA%E7%84%B6%E6%95%B0)均可写为质数的[积](https://zh.wikipedia.org/wiki/%E7%A7%AF)，而且这些素因子按大小排列之后，写法仅有一种方式** ，欧拉函数的一般推理形式

**第一种情况**

如果n=1，则 φ(1) = 1 。因为1与任何数（包括自身）都构成互质关系。

**第二种情况**

如果n是质数，则 $φ(n)=n-1$ 。因为质数与小于它的每一个数，都构成互质关系。比如5与1、2、3、4都构成互质关系。

**第三种情况**

如果n是质数的某一个次方，即$ n = p^k$ (p为质数，k为大于等于1的整数)，则

![img](http://chart.googleapis.com/chart?cht=tx&chl=%5Cphi(p%5E%7Bk%7D)%3Dp%5E%7Bk%7D-p%5E%7Bk-1%7D&chs=40)

比如 φ(8) = φ(2^3) =2^3 - 2^2 = 8 -4 = 4。

这是因为只有当一个数不包含质数p，才可能与n互质。而包含质数p的数一共有p^(k-1)个，即1×p、2×p、3×p、...、p^(k-1)×p，把它们去除，剩下的就是与n互质的数。

上面的式子还可以写成下面的形式：

![img](http://chart.googleapis.com/chart?cht=tx&chl=%5Cphi(p%5E%7Bk%7D)%3Dp%5E%7Bk%7D-p%5E%7Bk-1%7D%3Dp%5E%7Bk%7D(1-%5Cfrac%7B1%7D%7Bp%7D)&chs=60)

可以看出，上面的第二种情况是 k=1 时的特例。

**第四种情况**

如果n可以分解成两个互质的整数之积，

> 　　n = p1 × p2

则

> 　　φ(n) = φ(p1p2) = φ(p1)φ(p2)

即积的欧拉函数等于各个因子的欧拉函数之积。比如，$φ(56)=φ(8×7)=φ(8)×φ(7)=4×6=24$。

这一条的证明要用到["中国剩余定理"](http://en.wikipedia.org/wiki/Chinese_remainder_theorem)，这里就不展开了，只简单说一下思路：如果a与p1互质(a<p1)，b与p2互质(b<p2)，c与p1p2互质(c<p1p2)，则c与数对 (a,b) 是一一对应关系。由于a的值有φ(p1)种可能，b的值有φ(p2)种可能，则数对 (a,b) 有φ(p1)φ(p2)种可能，而c的值有φ(p1p2)种可能，所以φ(p1p2)就等于φ(p1)φ(p2)。

**第五种情况**

因为任意一个大于1的正整数，都可以写成一系列质数的积。

![img](http://chart.googleapis.com/chart?cht=tx&chl=n%3Dp_%7B1%7D%5E%7Bk_%7B1%7D%7Dp_%7B2%7D%5E%7Bk_%7B2%7D%7D...p_%7Br%7D%5E%7Bk_%7Br%7D%7D&chs=40)

根据第4条的结论，得到

![img](http://chart.googleapis.com/chart?cht=tx&chl=%5Cphi(n)%3D%5Cphi(p_%7B1%7D%5E%7Bk_%7B1%7D%7D)%5Cphi(p_%7B2%7D%5E%7Bk_%7B2%7D%7D)...%5Cphi(p_%7Br%7D%5E%7Bk_%7Br%7D%7D)&chs=40)

再根据第3条的结论，得到

![img](http://chart.googleapis.com/chart?cht=tx&chl=%5Cphi(n)%3Dp_%7B1%7D%5E%7Bk_%7B1%7D%7Dp_%7B2%7D%5E%7Bk_%7B2%7D%7D...p_%7Br%7D%5E%7Bk_%7Br%7D%7D(1-%5Cfrac%7B1%7D%7Bp_%7B1%7D%7D)(1-%5Cfrac%7B1%7D%7Bp_%7B2%7D%7D)...(1-%5Cfrac%7B1%7D%7Bp_%7Br%7D%7D)&chs=60)

也就等于

![img](http://chart.googleapis.com/chart?cht=tx&chl=%5Cphi(n)%3Dn(1-%5Cfrac%7B1%7D%7Bp_%7B1%7D%7D)(1-%5Cfrac%7B1%7D%7Bp_%7B2%7D%7D)...(1-%5Cfrac%7B1%7D%7Bp_%7Br%7D%7D)&chs=60)

这就是欧拉函数的通用计算公式。比如，1323的欧拉函数，计算过程如下：

![img](http://chart.googleapis.com/chart?cht=tx&chl=%5Cphi(1323)%3D%5Cphi(3%5E%7B3%7D%5Ctimes7%5E%7B2%7D)%3D1323(1-%5Cfrac%7B1%7D%7B3%7D)(1-%5Cfrac%7B1%7D%7B7%7D)%3D756&chs=60)





## 欧拉定理

如果两个正整数a和n互质，则n的欧拉函数 φ(n) 可以让下面的等式成立：

![img](http://chart.googleapis.com/chart?cht=tx&chl=a%5E%7B%5Cphi(n)%7D%5Cequiv%5C1%20(mod%5C%20n)&chs=60)



等同于：  **$a^{φ(n)} \%  n = 1$** a的φ(n)次方被n除的余数为1。

或者说，a的φ(n)次方减去1，可以被n整除。比如，3和7互质，而7的欧拉函数φ(7)等于6，所以3的6次方（729）减去1，可以被7整除（728/7=104）。

欧拉定理有一个特殊情况。

> 假设正整数a与质数p互质，因为质数p的φ(p)等于p-1，则欧拉定理可以写成
>
> ![img](http://chart.googleapis.com/chart?cht=tx&chl=a%5E%7Bp-1%7D%5Cequiv%5C%201%5C%20(mod%5C%20p)%20&chs=40)

这就是著名的[费马小定理](http://zh.wikipedia.org/wiki/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86)。它是欧拉定理的特例。

欧拉定理是RSA算法的核心。理解了这个定理，就可以理解RSA。



### **模反元素**

> **如果两个正整数a和n互质，那么一定可以找到整数b，使得 ab-1 被n整除，或者说ab被n除的余数是1。**
>
> ![img](http://chart.googleapis.com/chart?cht=tx&chl=ab%20%5Cequiv%201%5C%20(mod%5C%20n)&chs=40)
>
> 这时，b就叫做a的["模反元素"](http://zh.wikipedia.org/wiki/%E6%A8%A1%E5%8F%8D%E5%85%83%E7%B4%A0)。

比如，3和11互质，那么3的模反元素就是4，因为 (3 × 4)-1 可以被11整除。显然，模反元素不止一个， 4加减11的整数倍都是3的模反元素 {...,-18,-7,4,15,26,...}，即如果b是a的模反元素，则 b+kn 都是a的模反元素。

欧拉定理可以用来证明模反元素必然存在。

![img](http://chart.googleapis.com/chart?cht=tx&chl=a%5E%7B%5Cphi(n)%7D%3Da%5Ctimes%20a%5E%7B%5Cphi(n)-1%7D%5Cequiv%5C%201%5C%20(mod%5C%20n)%20&chs=40)

可以看到，a的 φ(n)-1 次方，就是a的模反元素。



## RSA算法

### 公钥与私钥的产生

> 一句话概括 **在R**SA 加密方案中，选定了p,q计算出N = p* q，再在小于 φ(n)的正整数中选一个和它互素的e作为公匙，它模 φ(n)的乘法逆元d 作为私匙。公开e,保留d



**第一步，随机选择两个不相等的质数p和q。**

爱丽丝选择了61和53。（实际应用中，这两个质数越大，就越难破解。）

**第二步，计算p和q的乘积n。**

爱丽丝就把61和53相乘。

> 　　n = 61×53 = 3233

n的长度就是密钥长度。3233写成二进制是110010100001，一共有12位，所以这个密钥就是12位。实际应用中，RSA密钥一般是1024位，重要场合则为2048位。

**第三步，计算n的欧拉函数φ(n)。**

根据公式：

> 　　$φ(n) = (p-1)(q-1)$

爱丽丝算出φ(3233)等于60×52，即3120。

**第四步，随机选择一个整数e，条件是1< e < φ(n)，且e与φ(n) 互质。**

爱丽丝就在1到3120之间，随机选择了17。（实际应用中，常常选择65537。）

**第五步，计算e对于φ(n)的模反元素d。**

所谓["模反元素"](http://zh.wikipedia.org/wiki/%E6%A8%A1%E5%8F%8D%E5%85%83%E7%B4%A0)就是指有一个整数d，可以使得$e*d$被φ(n)除的余数为1。

　　$e*d ≡ 1 (mod φ(n))$ 

这个式子等价于

> 　　$e*d$ - 1 = kφ(n) 

于是，找到模反元素d，实质上就是对下面这个二元一次方程求解。

> 　　ex + φ(n)y = 1

已知 e=17, φ(n)=3120，

> 　　17x + 3120y = 1

这个方程可以用["扩展欧几里得算法"](http://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95)求解，此处省略具体过程。总之，爱丽丝算出一组整数解为 (x,y)=(2753,-15)，即 d=2753。

至此所有计算完成。

**第六步，将n和e封装成公钥，n和d封装成私钥。**

在爱丽丝的例子中，n=3233，e=17，d=2753，所以公钥就是 (3233,17)，私钥就是（3233, 2753）。

实际应用中，公钥和私钥的数据都采用[ASN.1](http://zh.wikipedia.org/zh-cn/ASN.1)格式表达（[实例](http://hi.baidu.com/mathack/item/d0ad4cc1514a3663f7c95da2)）。

**七、RSA算法的可靠性**

回顾上面的密钥生成步骤，一共出现六个数字：

> 　　p
> 　　q
> 　　n
> 　　φ(n)
> 　　e
> 　　d

这六个数字之中，公钥用到了两个（n和e），其余四个数字都是不公开的。其中最关键的是d，因为n和d组成了私钥，一旦d泄漏，就等于私钥泄漏。

**那么，有无可能在已知n和e的情况下，推导出d？**

> 　　（1）$ed≡1 (mod φ(n)) $。只有知道e和φ(n)，才能算出d。
>
> 　　（2）φ(n)=(p-1)(q-1)。只有知道p和q，才能算出φ(n)。
>
> 　　（3）n=pq。只有将n因数分解，才能算出p和q。

**结论：如果n可以被因数分解，d就可以算出，也就意味着私钥被破解。**

可是，大整数的因数分解，是一件非常困难的事情。目前，除了暴力破解，还没有发现别的有效方法。维基百科这样写道：

> 　　"对极大整数做因数分解的难度决定了RSA算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA算法愈可靠。
>
> 　　假如有人找到一种快速因数分解的算法，那么RSA的可靠性就会极度下降。但找到这样的算法的可能性是非常小的。今天只有短的RSA密钥才可能被暴力破解。到2008年为止，世界上还没有任何可靠的攻击RSA算法的方式。
>
> 　　只要密钥长度足够长，用RSA加密的信息实际上是不能被解破的。"

举例来说，你可以对3233进行因数分解（61×53），但是你没法对下面这个整数进行因数分解。

> 　　12301866845301177551304949
> 　　58384962720772853569595334
> 　　79219732245215172640050726
> 　　36575187452021997864693899
> 　　56474942774063845925192557
> 　　32630345373154826850791702
> 　　61221429134616704292143116
> 　　02221240479274737794080665
> 　　351419597459856902143413

它等于这样两个质数的乘积：

> 　　33478071698956898786044169
> 　　84821269081770479498371376
> 　　85689124313889828837938780
> 　　02287614711652531743087737
> 　　814467999489
> 　　　　×
> 　　36746043666799590428244633
> 　　79962795263227915816434308
> 　　76426760322838157396665112
> 　　79233373417143396810270092
> 　　798736308917

事实上，这大概是人类已经分解的最大整数（232个十进制位，768个二进制位）。比它更大的因数分解，还没有被报道过，因此目前被破解的最长RSA密钥就是768位。

### 加密和解密

有了公钥和密钥，就能进行加密和解密了。

**（1）加密要用公钥 (n,e)**

假设鲍勃要向爱丽丝发送加密信息m，他就要用爱丽丝的公钥 (n,e) 对m进行加密。这里需要注意，m必须是整数（字符串可以取ascii值或unicode值），且m必须小于n。

所谓"加密"，就是算出下式的c：

> ​	$m^e  \% n = c$

爱丽丝的公钥是 (3233, 17)，鲍勃的m假设是65，那么可以算出下面的等式：

> ​	$6517 \% 3233 = 2790 $

于是，c等于2790，鲍勃就把2790发给了爱丽丝。

**（2）解密要用私钥(n,d)**

爱丽丝拿到鲍勃发来的2790以后，就用自己的私钥(3233, 2753) 进行解密。可以证明，下面的等式一定成立：

> ​	$c^d \% n =  m $  <=> $c^d \equiv m (mod n)$

也就是说，c的d次方除以n的余数为m。现在，c等于2790，私钥是(n,d) => (3233, 2753)，那么，爱丽丝算出

> ​       $2790 ^ {2753} \% 3233 = 65$　　<=>   $2790^{2753} ≡ 65 (mod 3233)​$  

因此，爱丽丝知道了鲍勃加密前的原文就是65。

至此，"加密--解密"的整个过程全部完成。

我们可以看到，如果不知道d，就没有办法从c求出m。而前面已经说过，要知道d就必须分解n，这是极难做到的，所以RSA算法保证了通信安全。

你可能会问，公钥(n,e) 只能加密小于n的整数m，那么如果要加密大于n的整数，该怎么办？有两种解决方法：一种是把长信息分割成若干段短消息，每段分别加密；另一种是先选择一种"对称性加密算法"（比如[DES](https://zh.wikipedia.org/wiki/%E8%B5%84%E6%96%99%E5%8A%A0%E5%AF%86%E6%A0%87%E5%87%86)），用这种算法的密钥加密信息，再用RSA公钥加密DES密钥。

**九、私钥解密的证明**

最后，我们来证明，为什么用私钥解密，一定可以正确地得到m。也就是证明下面这个式子：

　　$c^d ≡ m (mod n)$ => $c^d \% n = m$

因为，根据加密规则

　　$ｍ^e ≡ c (mod n)$ => $m^e \% n = c$

于是，c可以写成下面的形式：

> 　　$c = m^e - kn$

将c代入要我们要证明的那个解密规则：

> ​	  $ (m^e - kn)d ≡ m (mod n)$

它等同于求证

> 　　$m^{ed} ≡ m (mod n)$

由于 模范运算可知：

> 　　$ed ≡ 1 (mod φ(n)) $

所以

>  	$ed = hφ(n)+1$

将ed代入：

> 　	$m^{hφ(n)+1} ≡ m (mod n)$

接下来，分成两种情况证明上面这个式子。

**（1）m与n互质。**

根据欧拉定理，此时

> ​	$m^{φ(n)} ≡ 1 (mod n)$

得到

> 　	$(m^{φ(n)})h × m ≡ m (mod n)$

原式得到证明。

**（2）m与n不是互质关系。**

此时，由于n等于质数p和q的乘积，所以m必然等于kp或kq。

以 m = kp为例，考虑到这时k与q必然互质，则根据欧拉定理，下面的式子成立：

> 　　$(kp)^{q-1} ≡ 1 (mod q)$

进一步得到

>    　$[(kp)^{q-1}]h(p-1) × kp ≡ kp (mod q)$

即

> 　　$(kp)^{ed} ≡ kp (mod q)$

将它改写成下面的等式

> 　　$(kp)^{ed} = tq + kp$

这时t必然能被p整除，即 t=t'p

> 　　$(kp)^{ed} = t'pq + kp$

因为 m=kp，n=pq，所以

> 　　$m^{ed} ≡ m (mod n)$



