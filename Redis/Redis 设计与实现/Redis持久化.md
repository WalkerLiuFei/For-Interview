# Redis持久化

## RDB模式

RDB是将内存数据同步存储到`RDB`文件中,可以手动进行，也可以通过配置定期进行。

由于Redis是单线程应用，`SAVE`命令当然会阻塞服务器的进程。而`BGSAVE`是通过开启一个子进程来进行数据的持久化，通过子进程的方式而不是另外开始的方式是可以避免锁的竞争，通过子进程的方式，可以不降低原有的服务器的服务效率降低。

当`BGSAVE`命令工作时，服务器的`SAVE`,`BGREWRITEAOF`命令都会被阻塞执行防止产生竞争条件

`Redis`服务器通过`dirty` 计数器和`lastsave` 时间戳,加上配置，一块判断是否需要进行持久化





## AOF模式

AOF通过保存`REDIS`的执行**写命令**进行持久化。

### AOF持久化的实现

AOF持久化功能的实现可以分为命令追加`append`, 文件写入，文件同步`sync` 三个步奏

#### 命令追加

在Redis将命令执行完以后，命令会被追加到`aof_buf` 缓冲区的末尾，然后redis通过将这个缓冲区持久化到文件中，通过这样的方式完成的AOF持久化。

#### AOF文件写入与同步

AOF缓冲区持久化（文件写入，缓冲区flush）时间默认为1s， ，这个同步是专门的一个线程来执行的。

也可以通过 设置将缓冲区立即持久化到磁盘中（always模式），或者设置为系统调用，由系统完成缓冲区持久化。

这三种方式各有各的优势与缺陷，按照业务需求来进行配置。

### AOF的数据载入与还原

启动一个没有网络链接的伪Redis客户端来执行恢复AOF中所有的命令



### AOF重写

AOF重写其实就是减少AOF文件中的多余的写命令，比如

```
set a b
del a
```

通过`BGREWRITEAOF` 命令执行重写操作

#### AOF重写的实现原理

AOF重写的实现原理很简单，其实就是通过读取现在数据库的存储的状态，然后生成一系列存储命令。

```bash
10.199.5.217:6379> RPUSH list a b c
(integer) 3
10.199.5.217:6379> RPUSH list e d f
(integer) 6
10.199.5.217:6379> RPOP list
"f"
10.199.5.217:6379> RPOP list
"d"
```

这时候去重写的`AOF`文件的话，只需要读取内存中`list`的值并生成响应的命令即可

`RPUSH a b c e` 

当然，这个命令也是需要阻塞Redis服务器的。

#### AOF 后台重写

Redis通过开启一个后台的子进程来进行AOF文件的重写，采用子进程和RDB持久化使用子进程一样，拷贝内存，然后进行同步，避免的竞态出现。

在后台子进程进行重写时，主进程的Redis依然进行服务。那么这个时候问题来了，这样肯定会造成数据不一致的情况，Redis通过建立一个父子进程间的缓冲区（AOF重写缓冲区），在子进程进行重写过程中父进程将执行的写命令同步给子进程进行记录/执行。

所以后台重写时Redis的工作时

1. 执行命令
2. 将命令同步到aof_buffer，AOF缓冲区
3. 将命令同步到AOF 重写缓冲区



