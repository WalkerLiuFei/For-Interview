# HyperLogLog

### HyperLogLog底层实现

+ Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。

+ 在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，**在标准误差0.81%的前提下**，能够统计2^64个数据。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。

+ 但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身

HyperLogLog 用来统计有多少不同元素在一个`HyperLogLog`集合中有多少个不同的元素。

HyperLogLog  和布隆器很像都是通过Bitmap的方式实现的。**这都是概率统计，当数据量大到一定程度就不好使了** 

相对于HashSet，它能占用更少的空间。

## HyperLogLog的三个命令

```bash
# 创建一个HyperLogLog对象并添加5个元素
10.199.5.217:6379> PFADD test walker1 walker2 walker3 walker4
(integer) 1
# 添加一个已经在 HY 对象的元素，失败，返回0
10.199.5.217:6379> PFADD test walker1
(integer) 0
# 添加一个未在 HY 对象的元素，成功，返回1
10.199.5.217:6379> PFADD test walker5
(integer) 1
# 统计 hyperLogLog 对象 test 中元素个数
10.199.5.217:6379> PFCOUNT test
(integer) 5
10.199.5.217:6379> PFADD test2 walker2 walker3 walker10
(integer) 1
# 将 test 对象和test2对象merge 并赋值给 test
10.199.5.217:6379> PFMERGE test test test2
OK
10.199.5.217:6379> PFCOUNT test
(integer) 6
```



## 内存消耗

HyperLogLog主要是解决的是统计中的内存占用问题，当然是以概率为代价换的。



## 应用场景

HyperLogLog适用于那些大数据量对内存占用敏感，但是对精确性要求不高的场景

比如： **服务器访问IP数量的的统计**

自己的业务场景，就是区块链统计ETH上面出现了多少个有效的地址。

也可以做日活统计等等。不同于bitmap这种没有回退

## 底层算法



#### 1.比特串

通过`hash`函数，将数据转为`比特串`，例如输入5，便转为：101。为什么要这样转化呢？

是因为要和抛硬币对应上，`比特串`中，0 代表了反面，1 代表了正面，如果一个数据最终被转化了 `10010000`，那么从右往左，从低位往高位看，我们可以认为，首次出现 1 的时候，就是正面。

那么基于上面的估算结论，我们可以通过多次抛硬币实验的最大抛到正面的次数来预估总共进行了多少次实验，同样也就可以根据存入数据中，转化后的出现了 1 的最大的位置 k_max 来估算存入了多少数据。

#### 2.分桶

分桶就是分多少轮。抽象到计算机存储中去，就是存储的是一个以单位是比特(bit)，长度为 L 的大数组 S ，将 S 平均分为 m 组，注意这个 m 组，就是对应多少轮，然后每组所占有的比特个数是平均的，设为 P。容易得出下面的关系：

- L = S.length
- L = m * p
- 以 K 为单位，S 占用的内存 = L / 8 / 1024

在 `Redis` 中，`HyperLogLog`设置为：m=16834，p=6，L=16834 * 6。占用内存为=16834 * 6 / 8 / 1024 = 12K

形象化为：

```
  第0组     第1组                       .... 第16833组
[000 000] [000 000] [000 000] [000 000] .... [000 000]
复制代码
```

#### 3. 对应

现在回到我们的原始APP页面统计用户的问题中去。

- 设 APP 主页的 key 为： main
- 用户 id 为：idn , n->0,1,2,3....

在这个统计问题中，不同的用户 id 标识了一个用户，那么我们可以把用户的 id 作为被`hash`的输入。即：

> hash(id) = 比特串

不同的用户 id，必然拥有不同的`比特串`。每一个`比特串`，也必然会至少出现一次 1 的位置。我们类比每一个`比特串`为一次`伯努利试验`。

现在要`分轮`，也就是`分桶`。所以我们可以设定，每个`比特串`的前多少位转为10进制后，其值就对应于所在桶的标号。假设`比特串`的低两位用来计算桶下标志，此时有一个用户的id的`比特串`是：1001011000011。它的所在桶下标为：`11(2) = 1*2^1 + 1*2^0 = 3`，处于第3个桶，即第3轮中。

上面例子中，计算出桶号后，剩下的`比特串`是：10010110000，从低位到高位看，第一次出现 1 的位置是 5 。也就是说，此时第3个桶，第3轮的试验中，`k_max = 5`。5 对应的二进制是：101，又因为每个桶有 p 个比特位。当 p>=3 时，便可以将 101 存进去。

模仿上面的流程，多个不同的用户 id，就被分散到不同的桶中去了，且每个桶有其 k_max。然后当要统计出 `mian` 页面有多少用户点击量的时候，就是一次估算。最终结合所有桶中的 k_max，代入估算公式，便能得出估算值。

下面是 `HyperLogLog` 的结合了调和平均数的估算公式，变量释意和`LogLog`的一样:

