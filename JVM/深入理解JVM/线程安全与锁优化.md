# 线程安全与锁优化

## 线程安全

### 线程安全的定义

当多个线程访问同一个对象时，如果不考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他协调操作，调用对象的行为都可以获得正确的结果，那么这个操作就是线程安全的。

### java中的线程安全

#### 不可变

不可变很好理解，一个声明为`final`的就是不可变的，不需要考虑线程安全问题

#### 绝对线程安全

绝对线程安全指的是： 一个类不论运行时环境如何，调用者都不需要任何的额外同步措施。Java api中几乎不存在绝对线程安全的类。

#### 相对线程安全

相对线程安全是我们通常意义上的线程安全，它需要保证对这个对象单独的操作是线程安全的，我们在调用时不需要做做额外措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。

### 线程安全的实现方法

#### 互斥同步

最常见的实现方式，互斥同步保证一个变量在同一时间只有一个线程能够访问。互斥是一个实现同步的方式，而实现互斥可以通过`临界区(critical section)` ,`互斥量（mutex）` 和`信号量(semaphore)`实现。

在Java中，实现互斥的最基本手段就是使用`synchronized`关键字。因为`synchronized`是 重量级锁(未优化前提)，如果一个被`synchronzied`修饰的方法频繁的进行线程切换，因为线程切换是系统级别的，那么肯定会造成很大的开销，所以`synchronized` 是一个最末尾的选项。

对于`Retreenlock`，先对与`synchronized` 来说有以下优点

1. 使用灵活
2. 可以实现公平锁
3. 可以实现等待可中断 ： 等待时放弃等待
4. 锁绑定多个条件： 锁绑定多个条件是指，一个ReetenLock对象可以同步绑定多个`Condition`对象，而在`synchronized`中，锁对象的`wait()`,`notify()`,或`notifyAll()`方法可以实现一个隐含的条件，如果要多于一个条件关联的时候就不得不添加另外一个锁，而`Reentranlock` 无需这么做。

#### 非阻塞同步

互斥同步实现的悲观锁，其思想是只要不加锁操作就出问题。而乐观锁不同，乐观锁认为我操作时一般不会出问题，当我我操作出问题时再做补救。

乐观锁相对于悲观锁来说效率更高，不需要每一次操作都加锁，java的atomic就是典型的乐观锁实现。

Atomic通过CAS操作实现乐观锁，CAS操作需要3个操作数，分别是： 1. 内存位置 V，2，旧的预期值 A，3. 新的值B

1. 从内存位置读取到旧值
2. 读取到的旧值是否符合预期的旧值A
3. 如果符合将新值B填充
4. 最后无论成功与否都将旧址返回

比较特殊的一个Atmoic方法是`increaseGet()` ,它的语法是不断的尝试讲一个比当前值（预期）大1的新值赋予自己，如果失败了，那么说明在执行中已经被其他值操作过了，那么重新进行获取，increase，直到成功。

**那么问题来了，既然CAS（乐观锁）可以满足日常的同步问题（确实是这样），那么为什么还需要sync关键字哪？那是因为CAS无法防止 ABA问题**

所谓ABA问题指的是，如果两个thread 同时 R/W一个变量，如果这个变量在一个线程thread a 中被操作 A->B->A, 那么另外一个线程是不知道，它以为这个变量全程在thread a 中没被操作过，那么它就变为C。这种场景是CAS防止不了的，所以需要互斥同步

#### 无需同步

一些代码天生就是安全的

##### 可重入代码

如果一个方法，它的返回结果是可以预测的，即输入一个数必然得到一个相同的数据，那么这个方法就是线程安全的。

##### 线程本地存储



## 锁优化

锁优化的手段包括 ： 1. 适应性自旋，2.锁消除，3. 锁粗化，4. 轻量级锁 ， 5.  偏向锁等等

### 自旋锁与自适应自旋

自旋锁是相对于互斥锁而言的，互斥锁在遇到锁等待状态时通过sleep，然后在锁可用时主动被系统调用起来进行。但是这个过程中涉及到 用户/ os 上下文的切换。CPU强占，信号发送等开销

自旋锁就是在等待锁的过程中不释放CPU资源，一直等待锁的释放。这样就可以避免上下文切换和CPU抢占等开销。但是消耗CPU资源。

自旋锁换个互斥锁各有各的好处，jjdk通过对自旋次数进行优化当自旋超过一定次数，默认10次（--XX：+UseSpining） 时进行线程挂起释放CPU资源。

### 锁消除

通过`逃逸分析`可以知道，有些地方的代码（只在本地线程栈上运行）是无需加锁的， 但是由于各种原因代码加了锁，这种显然是浪费资源，JVM会在运行期内将代码进行优化，将锁消除

####轻量级锁

轻量级锁不是用来代替重量级锁（互斥锁）的，它是在没有多线程竞争的前提下，减少传统的重量级使用操作系统互斥量产生的性能消耗

轻量级锁的实现依赖于对象投的mark word 中2 bit的锁标志位

| 存储内容                             | 标志位 | 状态       |
| ------------------------------------ | ------ | ---------- |
| 对象Hash码，对象分代年龄             | 01     | 未锁定     |
| 指向锁记录的指针                     | 00     | 轻量级锁定 |
| 指向重量级锁的指针                   | 10     | 膨胀锁     |
| 空，不需要记录信息                   | 11     | GC标记     |
| 偏向线程ID，偏向时间错，对象分代年龄 | 01     | 可偏向     |



当线程一个线程在进入同步代码块时，首先通过CAS操作将锁对象的`MARK WORD`更新为`Lock Record`的指针，如果这个更新成功了，那么这个线程就拥有了该对象的锁，并且锁的标志位变为 `00`，如果这个更新失败了那么就检查当前线程是够已经获取了当前的锁，如果未获取到，那么锁的就要膨胀为重量级锁。



#### 偏向锁

通过 `mark word`的锁标志位可以看到，偏向锁的状态和未锁定状态都是一样的，很好理解，当一个对象一直只有一个线程R/W的时候，就没有同步的必要，只需要记录这个线程ID即可。

#### 锁的膨胀过程

对象A，如果一直被线程T1 R/W 的话，无需进行同步。只需要记录 thread id即可。当另外一个线程T2开始访问对象A时，它首先通过CAS操作拿到这个对象的锁，并更新锁的装态，现在进入轻量级锁。当T2对对象R/W完成以后如果T1再过来，那他通过CAS操作可以成功，锁也一致保持在轻量级锁的状态。如果当T2对对象A还没操作完，T1就回来抢夺对象A，那么这个时候就锁就需要膨胀成重量级锁(互斥锁)。











 