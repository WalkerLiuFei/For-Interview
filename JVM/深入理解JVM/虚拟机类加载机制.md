

## 类加载的时机

**类的生命周期**

1. 加载
2. 连接
   1. 验证
   2. 准备
   3. 解析
3. 初始化
4. 使用
5. 卸载

### 类的加载

对于类的加载来说，JVM并没有特定的标准，可以通过任何方式通过`class loader` 加载一个类。

#### 类加载的过程

1. 通过一个类的全限定名来定义此类的二进制字节流，一般包含报名类似 ： `L(java.lang.String)` 之类的。
2. 将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的 `java.lang.Class`对象,作为方法区这个类的运行时入口。这个对象一般可以通过类似`String.getClass()` 来访问

#### 数组类的特殊性

虽然说对于普通的类的二进制流的获取方式可以随意可控，但是对于数组类却不一样，`数组类不通过类加载器创建`是JVM创建的。



### 类的验证，准备，解析

#### 类的验证

	1. 文件格式的验证
 	2. 元数据验证
 	3. 字节码验证
 	4. 符号引用验证

对于虚拟机的类加载机制来说，验证阶段是一个非常重要，但是不一定必要（因为对程序运行期没有影响）的阶段，如果运行的全部代码已经可以保证安全，则可以通过`-Xverify:none` 参数来关闭大部分的验证措施，保证类加载的速度。

#### 类的准备

准备阶段时正式为类变量分配内存并设置类变量初始值的阶段，但是注意这个时候分配的变量的只是被`static` 修饰的类的变量的内存空间。另外，对于`final`修饰的变量，准备阶段会直接为其赋值静态值。

#### 类的解析

解析阶段时虚拟机将常量池内的符号引用替换为直接引用的过程。

1. 符号引用 ： 符号引用与内存布局无关，引用目标并不一定已经加载到内存中。
2. 直接引用 ： 直接引用可以是目标指针，相对偏移量或是一个能间接定位到目标的句柄。

### 类的初始化

#### 类初始化的条件

**当JVM遇到以下五种条件时，才会导致类的初始化**

+ 遇到对类进行`new`，`getstatic`,`putstatic`,`invokestatic` 时	
  + `new` : 创建一个类的对象
  + `putstatic` ,`putstatic`  ： 读取 / 设置一个类的静态变量（静态变量 被final修饰的除外，因为final修饰的变量是直接进入常量池的，不能通过读取/调用进行类的初始化）
  + `invokestatic` ： 调用一个类的静态方法
+ 反射调用
+ 一个类初始化时，要求父类必须初始化，所以通过子类，父类也可以初始化。反之不成立！
+ main方法所在的类
+ 调用java 1.7以后的动态语言支持的功能时。


```
class SuperClass{
    static {
        System.out.println("SuperClasss init");
    }
    public static String value = "123";
    //
    public static final String value2 = "1234";
}
class SubClass extends SuperClass{
    static {
        System.out.println("SubClass init");
    }
}
public class Classloader1 {
    public static void main(String[] args){
    	// 这一步并不会引起子类的初始化，因为调用的是父类的变量
    	System.out.print(SubClass.value);
        // 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，
        // 这样调用不会触发定义常量的类的初始化
        System.out.println(SubClass.value2);
        // 这样调用也不会初始化SubClass 或者SuperClass
        SubClass[] subClasses = new SubClass[]{};
    }
}

```

#### 类和接口初始化的区别

虽然类的初始化会引起其父类的初始化，但是接口不一样，只有当使用上接口父类的方法时，接口的父类才会被初始化。

#### 类的初始化过程

类的初始化实际上是执行的**类构造器<client>**方法的过程。

1. `<client>`方法是由`jvm` 通过手机类的所有静态变量赋值语句和`static{}`代码块生成的。
2. `<client>`方法和实例构造函数`<init>`不同，`<client>`方法不需要显示的调用父类的构造器。虚拟机会保证在子类的`<client>`方法调用之前，已经完成父类`<client>`方法的调用
3. 由于父类的`<client>`方法先执行，所以就意味着父类的`static`代码块先于子类的`static`代码块执行。
4. `client`方法对于类或者接口来说并不是必须的，也就是说没有静态语句，就没有这个方法。

###类加载器 

通过对类加载器的定制修改，可以进行代码加密的操作。

对于两个类的是否相等，不仅要判断他们被加载进入JVM时的二进制流是相同的，并且`要保证加载他们的类加载器`是一样的。这也是为什么实用双亲委派原则的原因。

#### 类加载器的分类

1. `bootstrap classloader` ： 其实是一个`C++` 对象，他负责将整个`<JAVA_HOME>\lib`中的类加载到JVM中，但是，对于那些不符合名称的类，即使放在lib文件夹下面其实也无法被加载。`bootstrap` 因为在JVM底层，其实它是无法被直接使用的
2. 扩展类加载器 （`Extension Classloader`）： 负责加载`<JAVA_HOME>\lib\ext`下的所有`java`文件 

#### 线程上下文类加载器

线程上下文类加载器可以破坏双亲委派原则，线程上下文类加载器其实在线程启动时主动赋值给它的，如果没有主动赋值，那么它的值是启动该线程的父线程的类加载器。 而`Main Thread`的`class loader` 是`AppClassloader`

####  Class.forName 和 Classloader.getName 

