# 深入理解JVM（第二章笔记）

### JVM内存区域
> jvm 按照线程安全进行分类：
> + 线程私有： 程序计数器，Java虚拟机栈，本地方法栈
> + 线程共享： Java堆，方法区，运行时常量池，直接内存(严格来说不是属于JVM的一部分)
#### 程序计数器
字节码解释器通过这个计数器来选择下一条要执行字节码指令。程序计数器是唯一一个不会出现OOM的内存区域

#### Java虚拟机栈
虚拟机栈描述的是Java方法执行的内存区域，每个方法执行的同时会创建一个栈帧，**栈帧用于存储局部变量表，操作数栈，动态 链表，方法出口等**
局部变量表用于存储**编译期**的各种基本数据类型，**对象引用**，这里常常跑出的异常是**StackOverFlowError**

#### Java堆
存放对象,现代的Jvm实现一般都会在JAVA堆上进行分代存储，这样能更加优于GC时的效率  Eden(新生代) 

#### 方法区
用于存储已加载过的类的信息，常量，静态变量，即时编译器编译后的代码等数据

#### 运行时常量池
**运行时常量池是方法区的一部分**

### 虚拟机中的对象

#### 对象的创建
1.  加载对应的类： 碰到`new`关键字，确定对应的 类是否加载过，如果没有加载，加载对应的类
2.  分配空间： 类加载过程中，会确定，类对应的对象的存储信息等
  `内存分配的动作按照 线程划分在每个线程的 Thread local allocation buffer 中，用于频繁创建对象的缓存`
3.  设置对象的必要信息： HashCode，锁信息，GC分代信息等

#### 对象的内存布局
对象在内存中分为三块区域： 对象头，实例数据，对齐填充

+ 对象头： 存储HashCode，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID,偏向时间戳，**类型指针**，如果是数组，还有一块存储数组长度的信息

##### 对象的访问定位
Java程序需要通过栈上的reference数据来操作堆上的具体对象
+ 句柄访问： java堆上开辟一块存储区域专门作为句柄池，句柄中包含了 实例数据与类型数据各自的具体地址信息
+ 直接地址访问
  区别： 使用句柄访问的好处是reference中存储的稳定的句柄地址，在对象被移动(GC 过程)，只会改变实例数据指针，而reference本身不会改变。 但是相对于直接指针访问会比较慢2