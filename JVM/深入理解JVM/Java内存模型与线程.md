# Java内存模型与线程

## Java内存模型

因为Java是一个跨平台的语言，所以Java的内存模型和具体平台没有必应关系但是Java内存模型（JMM）又可以利用特定平台的特定特性（寄存器，CPU缓存，GPU）来加速程序的效率。

### 主内存与工作内存

java规定了所有的对象(不包括逃逸分析中的对象)都保存在`主内存`中，另外每个线程也有自己的一块内存，又称之为工作内存，工作内存是线程私有的。

工作内存和主内存和 Java内存区域中的`堆`，`栈`，`方法区`并不是同一个层次的内存划分，如果要对应起来的话。从变量，主内存、工作内存的定义来看，主内存主要对应于`Java`堆中的对象实例数据部分，而工作内存则对应于虚拟栈中的部分区域。从更底层的角度来说，主内存直接对应于硬件的物理内存，而为了更好的运行速度，JVM会优先在寄存器或者CPU告诉缓存上分配工作内存。

**工作内存和主内存 之间的同步问题就是Java多线程问题处理的主要问题**

### 内存间交互操作

JVM定义了8种原子操作

1. `lock` ： 作用于主内存的变量，将一个变量设置为单一对象持有
2. `unlock` : 作用于主内存的变量，释放一个对象的线程锁定
3. `read` : 作用于主内存变量，它把一个变量的值从主内存传输到工作内存，以便后续的`load`指令的操作
4. `load` : 作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存中
5. `use`  : 作用于工作内存，将工作内存的一个变量值传递给执行引擎
6. `assign` : 作用于工作内存，从执行引擎将一个值赋值给变量。
7. `store` ： 作用于工作内存，主动将一个变量从工作内存传递到主内存中
8. `write` : 作用于主内存，讲一个`工作内存`中传递来的值存入到主内存中。

原子操作的要求 :

1. `load`和`read`,`store`和`write`必须成对出现。
2. 不允许一个线程丢弃它最近的`assign`操作，即变量在工作内存中改变了以后必须把变化同步到主内存中
3. 不允许在没有`assign`的前提下，数据从工作内存同步到了主内存中
4. 一个变量在进行`use`，`store`之前必须先执行过了`assign` 和`load`操作
5. 一个变量只允许被一个线程lock，允许多次lock，但是需要经过同样次数的unlock
6. **如果一个变量执行lock操作，会将清空工作内存中的值，在执行引擎使用这个变量前重新执行 load或assign初始化变量的值**
7. unlock之前必须要进行过lock操作，并且，unlock变量之后，变量值要同步会主内存中。

### volatile的特殊规则

#### 并发可见性

volatile 变量只能解决数据可见的问题，无法解决线程间的数据一致性问题。

比如下面这个场景，如果线程1和线程2同时运行，期待的结果应该是3，但是结果是2。

```
//全部变量
volatile int a = 0；

void method(){
 	a++;
}
// thread 1 run  method same time with thread 2
```

可以通过`Atomic`原子类或者进行加锁解决上述问题，显然`Atomic`原子类效率更高。`Atomic`通过`CAS`操作避免了加锁操作。

#### 防止指令重排序(volatile 与内存屏障)

普通变量仅仅能保证在该方法执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证操作的顺序与代码执行的顺序保持一致。

一个单例模式的`DCL`写法

```java
 static class Singleton {
        private volatile static Singleton instance;

        public static Singleton getInstance() {
            if (instance == null) {
                synchronized (Singleton.class) {
                    if (instance == null) {
                        instance = new Singleton();
                    }
                }
            }
            return instance;
        }
    }
```

`volatile`关键字的介入相当于为单例对象`instance` 增加一个内存屏障，**[内存屏障](https://zhuanlan.zhihu.com/p/43526907)指的是指令重排序时不能将指令后面的指令排到该指令之前的位置，当一个`CPU`访问内存时，并不需要内存屏障，但是如果有更多的CPU访问同一块内存时,且其中一个在观察另外一个，那么这个时候就需要内存屏障来保持一致性了**

`volatile` 变量在进行`read`，`load`，`use`，`assign`，`store`,`write`操作时需要满足以下条件

1. 线程 使用变量V，必须保证有 `read` ,`load`，`use`连续出现，且`assign`，`store`，`write`连续出现，这样就可以保证多个线程对变量V的操作都是可见的！

### 原子性，可见性，有序性

1. 原子性 ： 通过原子性的变量操作 `read`，`load`，`assign`,`use`,`store`,`write` 来保证原子性
2. 可见性 ： 可见性是指一个线程修改了一个变量V，那么另外一个线程可以立即知道这个修改
3. 有序性 ： 在本线程(A线程)中观察，本线程（A线程）的所有操作都是有序的，但是从另外的线程观察，A线程的所有操作都是无序的。前半句指的是"线程内串行执行的语义"，后半句表示的是”指令重排序“现象和”工作内存与主内存同步延迟“的现象。

#### 先行发生原则

先行发生是java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值，发送了消息调用了方法等等。

## Java 与线程

Java线程是系统级线程，Java线程的调度都是系统支持的。

### Java线程调度

线程调度分为同式线程调度和抢占式线程调度。，

同式线程调度是指调度由线程本身完成，在线程执行完毕以后主动通知另外一个行程执行。实现简单，但是问题很大，如果一个线程出了问题，那么整个应用都可能被拖死。

抢占式线程调度是指通过系统来分配执行时间，线程的切换不由线程本身完成。这样可以做到可控，即使有线程出了问题也不会拖累整个应用。

### 线程状态切换

Java线程的五个状态 

1. 新建 (New)： 创建后尚未启动
2. 运行 （Runable）:  Runable状态包含了操作系统线程状态中的Running和Ready两个状态，它可能是在运行中，也可能是在等待系统给它分配运行时间。
3. 无限期等待（Waiting） ： 处在这个状态的线程不会占用CPU 执行时间，他们要等待其他线程显式的唤醒，进入waiting状态的方式
   1. 没有设置Timeout的 Object.wait()
   2. 没有设置Timeout的 Thread.join()
   3. LockSupport.park() 方法
4. 限期等待（Timed Waiting） ：  处于这种状态的线程也不会占用CPU时间，但是无需其他线程唤醒，在达到一定时间后会自动被系统唤醒,以下方式可以进入限期等待
   1. Thread.sleep()
   2.  设置Timeout的 Object.wait()
   3. 设置Timeout的 Thread.join()
5. 阻塞（Blocked） ：线程被阻塞，可能是在等待一个锁，是占用CPU时间的
6. 结束（terminal） 















