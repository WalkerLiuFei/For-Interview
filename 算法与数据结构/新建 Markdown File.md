# 令牌桶算法

在开发高并发系统时有三把利器用来保护系统：**缓存、降级和限流**

**缓存**：缓存的目的是提升系统访问速度和增大系统处理容量
**降级**：降级是当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行
**限流**：限流的目的是通过对并发访问/请求进行限速，或者对一个时间窗口内的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务、排队或等待、降级等处理



`参考hytrix`

## 限流算法

 而Google开源项目Guava中的RateLimiter使用的就是令牌桶控制算法。同样的，这个算法也被应用在kubectl 调用 apiserver 的过程中。 **另外，Golang的原生包 ： `"golang.org/x/time/rate"` 也实现了token bucket 算法**

**z这个限流算法是控制在 client端的，别理解错误！**



原理就是 初始化为 100 qps，那么每取出一个 token就要等待 10ms， 通过这种方式进行限流，这个限流算法是



```
指定每秒放1个令牌，RateLimiter具有预消费的能力：

acquire 1 时，并没有任何等待 0.0 秒 直接预消费了1个令牌
acquire 10时，由于之前预消费了 1 个令牌，故而等待了1秒，之后又预消费了10个令牌
acquire 2 时，由于之前预消费了 10 个令牌，故而等待了10秒，之后又预消费了2个令牌
acquire 20 时，由于之前预消费了 2 个令牌，故而等待了2秒，之后又预消费了20个令牌
acquire 2 时，由于之前预消费了 20 个令牌，故而等待了20秒，之后又预消费了2个令牌
acquire 2 时，由于之前预消费了 2 个令牌，故而等待了2秒，之后又预消费了2个令牌
acquire 2 时 .....

通俗的讲「前人_挖坑_后人跳」,也就说上一次请求获取的permit数越多，那么下一次再获取授权时更待的时候会更长，反之，如果上一次获取的少，那么时间向后推移的就少，下一次获得许可的时间更短。可见，都是有代价的。正所谓：要浪漫就要付出代价。马上就七夕了，浪漫的代价可能要花钱啊，单身狗们。
```

